<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>Prediksi Bola Engine — SUPREME PARLAY FINAL</title>
<style>
body {
    background:#111;
    color:#eee;
    font-family:Arial, sans-serif;
    padding:20px;
}
.container {
    max-width:1100px;
    margin:auto;
}
.card {
    background:#1a1a1a;
    padding:15px;
    border-radius:10px;
    margin-bottom:20px;
    border:1px solid #333;
}
.card h2 {
    margin-top:0;
    color:#58a6ff;
}
input, select {
    width:100%;
    padding:8px;
    background:#000;
    border:1px solid #444;
    color:#fff;
    border-radius:5px;
    margin-top:4px;
    margin-bottom:10px;
}
button {
    background:#007bff;
    border:none;
    padding:10px 18px;
    border-radius:6px;
    color:white;
    margin:5px 0;
    cursor:pointer;
}
button:hover {
    background:#2491ff;
}
textarea {
    width:100%;
    height:280px;
    background:#000;
    border:1px solid #444;
    padding:10px;
    color:#0f0;
    border-radius:6px;
    margin-top:10px;
    white-space:pre-wrap;
}
.flex {
    display:flex;
    gap:10px;
}
.flex > div {
    flex:1;
}
.subnote {
    font-size:12px;
    color:#aaa;
}
</style>
</head>
<body>
<div class="container">

<div class="card">
    <h2>Prediksi Bola — Parlay SUPREME Engine</h2>
    <div class="flex">
        <div>
            <label>Tim Home</label>
            <input id="home_team" placeholder="Home">
            <label>xG Home</label>
            <input id="home_xg">
            <label>xGA Home</label>
            <input id="home_xga">
            <label>Error Def Home</label>
            <input id="home_err">
            <label>Stability Home</label>
            <input id="home_stab">
            <label>Momentum Home</label>
            <input id="home_mom">
        </div>

        <div>
            <label>Tim Away</label>
            <input id="away_team" placeholder="Away">
            <label>xG Away</label>
            <input id="away_xg">
            <label>xGA Away</label>
            <input id="away_xga">
            <label>Error Def Away</label>
            <input id="away_err">
            <label>Stability Away</label>
            <input id="away_stab">
            <label>Momentum Away</label>
            <input id="away_mom">
        </div>
    </div>

    <label>Pressing Home</label>
    <input id="home_press">

    <label>Pressing Away</label>
    <input id="away_press">

    <label>Match Importance (1–5)</label>
    <input id="match_importance" value="3">

    <div class="subnote">Opsional (untuk Market Edge & BRM berbasis odds real):</div>
    <div class="flex">
        <div>
            <label>Odds Home (desimal)</label>
            <input id="odds_home" placeholder="">
        </div>
        <div>
            <label>Odds Draw (desimal)</label>
            <input id="odds_draw" placeholder="">
        </div>
        <div>
            <label>Odds Away (desimal)</label>
            <input id="odds_away" placeholder="">
        </div>
    </div>

    <button id="btn_auto">Auto Calc (TCI + Dynamic xG)</button>
</div>

<div class="card">
    <h2>Engine Tombol (Core + God + Supreme)</h2>
    <!-- CORE -->
    <button id="btn_analyze">PRIME</button>
    <button id="btn_hybrid">HYBRID</button>
    <button id="btn_grand_unified">INFINITY</button>
    <button id="btn_dxg">Dynamic xG</button>
    <button id="btn_ou_heat">OU Heat</button>
    <button id="btn_scoregrid">Correct Score Grid</button>
    <button id="btn_brm">BRM</button>
    <br>
    <!-- GOD MODE -->
    <button id="btn_composite">COMPOSITE MODEL</button>
    <button id="btn_confidence">CONFIDENCE INDEX</button>
    <button id="btn_parlay_ai">PARLAY AI BUILDER</button>
    <button id="btn_market_edge">MARKET EDGE ANALYZER</button>
    <button id="btn_team_id">TEAM IDENTITY</button>
    <br>
    <!-- SUPREME -->
    <button id="btn_supreme">SUPREME ENGINE (AI DECISION)</button>
</div>

<div class="card">
    <h2>Output</h2>
    <textarea id="analysis_output"></textarea>
</div>

<script>
// ======================================================
// CORE ENGINE (PSZ) + UTILITAS
// ======================================================
const PSZ = {
    state: {},

    el(id) {
        return document.getElementById(id);
    },

    num(id) {
        const el = this.el(id);
        if (!el) return 0;
        const raw = el.value.toString().replace(",", ".");
        const v = parseFloat(raw);
        return isNaN(v) ? 0 : v;
    },

    val(id) {
        const el = this.el(id);
        return el ? el.value : "";
    },

    log(msg) {
        const ta = this.el("analysis_output");
        if (!ta) return;
        const time = new Date().toLocaleTimeString();
        ta.value += `[${time}] ${msg}\n`;
        ta.scrollTop = ta.scrollHeight;
    }
};

// Helper: tim & xG dasar
PSZ.getTeams = function () {
    return {
        home: (PSZ.val("home_team") || "HOME").trim(),
        away: (PSZ.val("away_team") || "AWAY").trim()
    };
};

PSZ.getBaseXG = function () {
    return {
        hxg: PSZ.num("home_xg"),
        axg: PSZ.num("away_xg"),
        hxga: PSZ.num("home_xga"),
        axga: PSZ.num("away_xga")
    };
};

PSZ.getPressing = function () {
    let pressH = PSZ.num("home_press");
    let pressA = PSZ.num("away_press");

    if (!pressH) pressH = 7;
    if (!pressA) pressA = 7;

    return { pressH, pressA };
};

// ======================================================
// TCI FUSION v9
// ======================================================
PSZ.autoTCI = function () {
    PSZ.log("=== AUTO TCI v9 START ===");

    const { pressH, pressA } = PSZ.getPressing();

    const errH  = PSZ.num("home_err");
    const errA  = PSZ.num("away_err");
    const stabH = PSZ.num("home_stab");
    const stabA = PSZ.num("away_stab");
    const momH  = PSZ.num("home_mom");
    const momA  = PSZ.num("away_mom");

    const impRaw = PSZ.val("match_importance") || "3";
    let importance = Number(impRaw);

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    let tempoH = (pressH * 0.8) + (momH * 0.5) - (stabH * 0.3);
    let tempoA = (pressA * 0.8) + (momA * 0.5) - (stabA * 0.3);

    let chaosH = (errH * 0.7) + (pressH * 0.4) + (momH * 0.3);
    let chaosA = (errA * 0.7) + (pressA * 0.4) + (momA * 0.3);

    tempoH = clamp(tempoH, 1, 10);
    tempoA = clamp(tempoA, 1, 10);
    chaosH = clamp(chaosH, 1, 10);
    chaosA = clamp(chaosA, 1, 10);
    importance = clamp(importance, 1, 5);

    let tempo = (tempoH + tempoA) / 2;
    let chaos = (chaosH + chaosA) / 2;

    tempo = clamp(tempo, 1, 10);
    chaos = clamp(chaos, 1, 10);

    PSZ.state.tci_profile = {
        tempoH,
        tempoA,
        chaosH,
        chaosA,
        tempo: { global: tempo },
        chaos: { global: chaos },
        importance
    };

    PSZ.log(`TCI v9 → TempoH: ${tempoH.toFixed(2)} | TempoA: ${tempoA.toFixed(2)}`);
    PSZ.log(`TCI v9 → ChaosH: ${chaosH.toFixed(2)} | ChaosA: ${chaosA.toFixed(2)}`);
    PSZ.log(`TCI v9 → TempoG: ${tempo.toFixed(2)} | ChaosG: ${chaos.toFixed(2)}`);
    PSZ.log(`TCI v9 → Importance: ${importance.toFixed(2)}`);
    PSZ.log("=== AUTO TCI v9 END ===");
    PSZ.log("");

    return PSZ.state.tci_profile;
};

// ======================================================
// Dynamic xG (d-xG) v1
// ======================================================
PSZ.dynamicXG = function () {
    const teams = PSZ.getTeams();
    const { hxg, axg } = PSZ.getBaseXG();
    const TCI = PSZ.state.tci_profile || PSZ.autoTCI();

    const tempo = (
        (TCI.tempoH ?? TCI.tempo?.global ?? 5) +
        (TCI.tempoA ?? TCI.tempo?.global ?? 5)
    ) / 2;

    const chaos = (
        (TCI.chaosH ?? TCI.chaos?.global ?? 5) +
        (TCI.chaosA ?? TCI.chaos?.global ?? 5)
    ) / 2;

    const imp = TCI.importance ?? 3;

    const normTempo = tempo / 10;
    const normChaos = chaos / 10;

    const homeBoost = 1 + (normTempo * 0.25) + (normChaos * 0.15);
    const awayBoost = 1 + (normTempo * 0.20) + (normChaos * 0.20);

    const hxg_dyn = hxg * homeBoost;
    const axg_dyn = axg * awayBoost;

    const total_xg = hxg_dyn + axg_dyn;
    let line = 2.5;
    if (total_xg > 3.2) line = 3.0;
    if (total_xg < 2.1) line = 2.0;

    const txt = [];
    txt.push("=== Dynamic xG v1 (TCI Fusion) ===");
    txt.push(`Match: ${teams.home} vs ${teams.away}`);
    txt.push(`Base xG Home: ${hxg.toFixed(2)} → Dynamic: ${hxg_dyn.toFixed(2)}`);
    txt.push(`Base xG Away: ${axg.toFixed(2)} → Dynamic: ${axg_dyn.toFixed(2)}`);
    txt.push(`Tempo Avg: ${tempo.toFixed(2)} | Chaos Avg: ${chaos.toFixed(2)} | Importance: ${imp.toFixed(2)}`);
    txt.push(`Total Dynamic xG: ${total_xg.toFixed(2)} → OU line model: ${line.toFixed(1)}`);
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.dxg = { hxg_dyn, axg_dyn, total_xg, line };
    return PSZ.state.dxg;
};

// ======================================================
// PRIME ENGINE v4 (1X2 + OU baseline)
// ======================================================
PSZ.runPrime = function () {
    const teams = PSZ.getTeams();
    const { hxg, axg, hxga, axga } = PSZ.getBaseXG();
    const TCI = PSZ.state.tci_profile || PSZ.autoTCI();

    const tempo = TCI.tempo?.global ?? 5;
    const chaos = TCI.chaos?.global ?? 5;

    const homeAdv = 0.35;

    const homeAttack = hxg - axga + homeAdv;
    const awayAttack = axg - hxga;

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    const homeRating = clamp(homeAttack + tempo * 0.05 - chaos * 0.03, -2, 2);
    const awayRating = clamp(awayAttack + tempo * 0.03 - chaos * 0.02, -2, 2);

    const toProb = (r) => 1 / (1 + Math.exp(-r));

    const pHomeBase = toProb(homeRating);
    const pAwayBase = toProb(awayRating);

    let pHome = pHomeBase * 0.6;
    let pAway = pAwayBase * 0.6;
    let pDraw = 1 - (pHome + pAway);

    if (pDraw < 0.15) {
        const diff = 0.15 - pDraw;
        pHome -= diff / 2;
        pAway -= diff / 2;
        pDraw = 0.15;
    }

    const sum = pHome + pDraw + pAway;
    pHome /= sum;
    pDraw /= sum;
    pAway /= sum;

    const total_xg = (hxg + axg);
    let line = 2.5;
    if (total_xg > 3.2) line = 3.0;
    if (total_xg < 2.1) line = 2.0;

    const txt = [];
    txt.push("=== PRIME ENGINE v4 ===");
    txt.push(`Match : ${teams.home} vs ${teams.away}`);
    txt.push(`Tempo : ${tempo.toFixed(2)} | Chaos: ${chaos.toFixed(2)}`);
    txt.push(`Base xG H/A: ${hxg.toFixed(2)} / ${axg.toFixed(2)}`);
    txt.push("");
    txt.push(`Prob HOME : ${(pHome * 100).toFixed(1)} %`);
    txt.push(`Prob DRAW : ${(pDraw * 100).toFixed(1)} %`);
    txt.push(`Prob AWAY : ${(pAway * 100).toFixed(1)} %`);
    txt.push("");
    txt.push(`OU baseline (xG): ${line.toFixed(1)} gol`);
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.prime = { pHome, pDraw, pAway, line };
    return PSZ.state.prime;
};

// ======================================================
// HYBRID ENGINE v3
// ======================================================
PSZ.runHybrid = function () {
    const dxg = PSZ.state.dxg || PSZ.dynamicXG();
    const prime = PSZ.state.prime || PSZ.runPrime();

    const total_xg = dxg.total_xg;
    let line = dxg.line;

    if (prime.pHome > 0.55 && total_xg > 2.4) {
        line += 0.25;
    }
    if (prime.pAway > 0.55 && total_xg > 2.6) {
        line += 0.25;
    }

    const txt = [];
    txt.push("=== HYBRID ENGINE v3 ===");
    txt.push(`Total Dynamic xG: ${total_xg.toFixed(2)}`);
    txt.push(`Prime 1X2 → H: ${(prime.pHome * 100).toFixed(1)}% | D: ${(prime.pDraw * 100).toFixed(1)}% | A: ${(prime.pAway * 100).toFixed(1)}%`);
    txt.push(`Hybrid OU line: ${line.toFixed(2)}`);
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.hybrid = { hybrid_line: line };
    return PSZ.state.hybrid;
};

// ======================================================
// INFINITY ENGINE (Grand Unified)
// ======================================================
PSZ.runInfinity = function () {
    const dxg = PSZ.state.dxg || PSZ.dynamicXG();
    const prime = PSZ.state.prime || PSZ.runPrime();
    const hybrid = PSZ.state.hybrid || PSZ.runHybrid();
    const TCI = PSZ.state.tci_profile || PSZ.autoTCI();

    const tempo = TCI.tempo?.global ?? 5;
    const chaos = TCI.chaos?.global ?? 5;

    const riskIndex = (tempo + chaos) / 2;
    const safeMode = riskIndex < 5;

    const txt = [];
    txt.push("=== INFINITY ENGINE v3 ===");
    txt.push(`Tempo: ${tempo.toFixed(2)} | Chaos: ${chaos.toFixed(2)} | RiskIndex: ${riskIndex.toFixed(2)}`);
    txt.push(`Prime 1X2 → H/D/A = ${(prime.pHome*100).toFixed(1)} / ${(prime.pDraw*100).toFixed(1)} / ${(prime.pAway*100).toFixed(1)} %`);
    txt.push(`Dynamic total xG: ${dxg.total_xg.toFixed(2)} | Hybrid OU: ${hybrid.hybrid_line.toFixed(2)}`);
    txt.push("");
    if (safeMode) {
        txt.push("Mode: SAFE / CONTROL → fokus double chance, under terkendali, handicap ringan.");
    } else {
        txt.push("Mode: AGGRESSIVE / CHAOTIC → fokus over, BTTS, scoreline tinggi, parlay agresif.");
    }
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.infinity = { riskIndex, safeMode };
    return PSZ.state.infinity;
};

// ======================================================
// OU HEAT ENGINE
// ======================================================
PSZ.runOUHeat = function () {
    const dxg = PSZ.state.dxg || PSZ.dynamicXG();
    const TCI = PSZ.state.tci_profile || PSZ.autoTCI();

    const tempo = TCI.tempo?.global ?? 5;
    const chaos = TCI.chaos?.global ?? 5;

    const heatIndex = (dxg.total_xg * 0.6) + (tempo * 0.2) + (chaos * 0.2);

    let tag = "NETRAL";
    if (heatIndex >= 18) tag = "HIGH OVER ZONE";
    else if (heatIndex <= 11) tag = "LOW / UNDER ZONE";

    const txt = [];
    txt.push("=== OU HEAT ENGINE ===");
    txt.push(`Total Dynamic xG: ${dxg.total_xg.toFixed(2)}`);
    txt.push(`Tempo: ${tempo.toFixed(2)} | Chaos: ${chaos.toFixed(2)}`);
    txt.push(`Heat Index: ${heatIndex.toFixed(2)} → ${tag}`);
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.ou_heat = { heatIndex, tag };
    return PSZ.state.ou_heat;
};

// ======================================================
// CORRECT SCORE GRID v2
// ======================================================
PSZ.runScoreGrid = function () {
    const teams = PSZ.getTeams();
    const dxg = PSZ.state.dxg || PSZ.dynamicXG();
    const TCI = PSZ.state.tci_profile || PSZ.autoTCI();

    const tempo = (
        (TCI.tempoH ?? TCI.tempo?.global ?? 5) +
        (TCI.tempoA ?? TCI.tempo?.global ?? 5)
    ) / 2;
    const chaos = (
        (TCI.chaosH ?? TCI.chaos?.global ?? 5) +
        (TCI.chaosA ?? TCI.chaos?.global ?? 5)
    ) / 2;

    const hxg = dxg.hxg_dyn ?? dxg.hxg ?? PSZ.num("home_xg");
    const axg = dxg.axg_dyn ?? dxg.axg ?? PSZ.num("away_xg");

    const maxGoals = 4;
    const grid = [];
    let totalWeight = 0;

    for (let gh = 0; gh <= maxGoals; gh++) {
        for (let ga = 0; ga <= maxGoals; ga++) {
            const diffH = Math.abs(gh - hxg);
            const diffA = Math.abs(ga - axg);

            let w = Math.exp(-diffH) * Math.exp(-diffA);

            const highScore = (gh + ga) >= 4;
            if (highScore) {
                w *= (1 + chaos / 10);
            }

            if (!(gh === 0 && ga === 0)) {
                w *= (1 + tempo / 15);
            }

            grid.push({ gh, ga, w });
            totalWeight += w;
        }
    }

    grid.forEach(c => c.p = c.w / totalWeight);

    grid.sort((a, b) => b.p - a.p);
    const top = grid.slice(0, 6);

    const txt = [];
    txt.push("=== CORRECT SCORE GRID v2 ===");
    txt.push(`Match: ${teams.home} vs ${teams.away}`);
    txt.push(`Dynamic xG H/A: ${hxg.toFixed(2)} / ${axg.toFixed(2)}`);
    txt.push(`Tempo Avg: ${tempo.toFixed(2)} | Chaos Avg: ${chaos.toFixed(2)}`);
    txt.push("");
    txt.push("Top Scorelines (probabilitas model):");

    top.forEach(c => {
        const label = `${c.gh}-${c.ga}`;
        const prob = (c.p * 100).toFixed(2);
        txt.push(`- ${label}  → ~ ${prob}%`);
    });

    txt.push("");
    PSZ.log(txt.join("\n"));

    PSZ.state.scoregrid = { top };
    return PSZ.state.scoregrid;
};

// ======================================================
// BRM (Bankroll Management) — Berbasis odds input
// ======================================================
PSZ.runBRM = function () {
    const prime = PSZ.state.prime || PSZ.runPrime();
    const teams = PSZ.getTeams();

    const oh = PSZ.num("odds_home");
    if (!oh) {
        const txtNo = [];
        txtNo.push("=== BRM ===");
        txtNo.push("Data odds Home belum diisi. BRM membutuhkan odds nyata untuk menghitung.");
        txtNo.push("");
        PSZ.log(txtNo.join("\n"));
        return;
    }

    const modelProbHome = prime.pHome;
    const marketProbHome = 1 / oh;
    const edge = modelProbHome - marketProbHome;

    const txt = [];
    txt.push("=== BRM (Bankroll Management) ===");
    txt.push(`Jalur dianalisis: HOME (${teams.home})`);
    txt.push(`Probabilitas model: ${(modelProbHome*100).toFixed(2)}%`);
    txt.push(`Probabilitas market (dari odds): ${(marketProbHome*100).toFixed(2)}%`);
    txt.push(`Edge model vs market: ${(edge*100).toFixed(2)}%`);

    if (edge <= 0) {
        txt.push("Tidak ada edge positif yang jelas. Disarankan menurunkan stake atau mencari match lain.");
    } else {
        const odds = oh;
        const p = modelProbHome;
        const q = 1 - p;
        const kelly = (p * (odds - 1) - q) / (odds - 1);
        const safeKelly = Math.max(0, kelly) * 0.5;

        txt.push(`Estimasi fraksi Kelly (teoretis): ${(kelly*100).toFixed(2)}% dari bankroll.`);
        txt.push(`Saran konservatif (half-Kelly): ${(safeKelly*100).toFixed(2)}% dari bankroll.`);
        txt.push("Angka ini murni perhitungan matematis berdasarkan input saat ini.");
    }

    txt.push("");
    PSZ.log(txt.join("\n"));

    PSZ.state.brm = { edge };
    return PSZ.state.brm;
};

// ======================================================
// GOD MODE MODULES
// ======================================================

// Composite Model
PSZ.runCompositeModel = function () {
    const prime = PSZ.state.prime || PSZ.runPrime();
    const dxg   = PSZ.state.dxg   || PSZ.dynamicXG();
    const heat  = PSZ.state.ou_heat || PSZ.runOUHeat();
    const TCI   = PSZ.state.tci_profile || PSZ.autoTCI();
    const teams = PSZ.getTeams();

    const tempo = TCI.tempo?.global ?? 5;
    const chaos = TCI.chaos?.global ?? 5;
    const riskIndex = (tempo + chaos) / 2;

    const offensiveBias = heat.tag === "HIGH OVER ZONE" ? 0.03 : 0;
    const defensiveBias = heat.tag === "LOW / UNDER ZONE" ? -0.03 : 0;

    let pHome = prime.pHome + offensiveBias + defensiveBias * 0.5;
    let pDraw = prime.pDraw + defensiveBias;
    let pAway = prime.pAway + offensiveBias + defensiveBias * 0.5;

    const sum = pHome + pDraw + pAway;
    pHome /= sum; pDraw /= sum; pAway /= sum;

    const txt = [];
    txt.push("=== COMPOSITE MODEL (God Mode) ===");
    txt.push(`Match: ${teams.home} vs ${teams.away}`);
    txt.push(`Tempo: ${tempo.toFixed(2)} | Chaos: ${chaos.toFixed(2)} | RiskIndex: ${riskIndex.toFixed(2)}`);
    txt.push(`Dynamic total xG: ${dxg.total_xg.toFixed(2)} | OU Heat: ${heat.tag}`);
    txt.push("");
    txt.push("Probabilitas 1X2 (Composite):");
    txt.push(`HOME : ${(pHome*100).toFixed(2)} %`);
    txt.push(`DRAW : ${(pDraw*100).toFixed(2)} %`);
    txt.push(`AWAY : ${(pAway*100).toFixed(2)} %`);
    txt.push("");

    PSZ.log(txt.join("\n"));

    PSZ.state.composite = { pHome, pDraw, pAway, riskIndex };
    return PSZ.state.composite;
};

// Confidence Index

PSZ.runConfidenceIndex = function () {

    const comp = PSZ.state.composite || PSZ.runCompositeModel();

    const TCI  = PSZ.state.tci_profile || PSZ.autoTCI();

    const inf  = PSZ.state.infinity || PSZ.runInfinity();

    const teams = PSZ.getTeams();



    const tempo = TCI.tempo?.global ?? 5;

    const chaos = TCI.chaos?.global ?? 5;



    const maxProb = Math.max(comp.pHome, comp.pDraw, comp.pAway);

    const margin = maxProb - (1/3);



    const predictability = Math.max(0, (10 - chaos + tempo) / 2);



    let cIndex = (margin * 100) * 0.6 + predictability * 4;



    if (!inf.safeMode) {

        cIndex *= 0.9;

    }



    if (cIndex < 0) cIndex = 0;

    if (cIndex > 100) cIndex = 100;



    let tag = "CHAOTIC / LOW";

    if (cIndex >= 70) tag = "HIGH";

    else if (cIndex >= 45) tag = "MEDIUM";



    const txt = [];

    txt.push("=== CONFIDENCE INDEX (C-Index) ===");

    txt.push(`Match: ${teams.home} vs ${teams.away}`);

    txt.push(`C-Index: ${cIndex.toFixed(1)} / 100 (${tag})`);

    txt.push(`Predictability: ${predictability.toFixed(2)} / 10`);

    txt.push(`Infinity Mode: ${inf.safeMode ? "SAFE" : "AGGRESSIVE"}`);

    txt.push("");



    PSZ.log(txt.join("\n"));



    PSZ.state.confidence = { cIndex, tag, predictability };

    return PSZ.state.confidence;

};



// Market Edge Analyzer

PSZ.runMarketEdge = function () {

    const comp  = PSZ.state.composite || PSZ.runCompositeModel();

    const teams = PSZ.getTeams();



    const oh = PSZ.num("odds_home");

    const od = PSZ.num("odds_draw");

    const oa = PSZ.num("odds_away");



    const txt = [];

    txt.push("=== MARKET EDGE ANALYZER ===");

    txt.push(`Match: ${teams.home} vs ${teams.away}`);



    if (!oh || !od || !oa) {

        txt.push("Data odds HOME/DRAW/AWAY belum lengkap. Analisa edge membutuhkan semua odds.");

        txt.push("");

        PSZ.log(txt.join("\n"));

        return;

    }



    const pMktH = 1 / oh;

    const pMktD = 1 / od;

    const pMktA = 1 / oa;

    const sum   = pMktH + pMktD + pMktA;

    const adjH = pMktH / sum;

    const adjD = pMktD / sum;

    const adjA = pMktA / sum;



    const edgeH = comp.pHome - adjH;

    const edgeD = comp.pDraw - adjD;

    const edgeA = comp.pAway - adjA;



    const fmt = (x) => (x*100).toFixed(2);



    txt.push("Model vs Market (probabilitas):");

    txt.push(`HOME : model ${fmt(comp.pHome)}% vs market ${fmt(adjH)}% → edge ${fmt(edgeH)}%`);

    txt.push(`DRAW : model ${fmt(comp.pDraw)}% vs market ${fmt(adjD)}% → edge ${fmt(edgeD)}%`);

    txt.push(`AWAY : model ${fmt(comp.pAway)}% vs market ${fmt(adjA)}% → edge ${fmt(edgeA)}%`);



    const edges = [

        { side: "HOME", edge: edgeH, odds: oh },

        { side: "DRAW", edge: edgeD, odds: od },

        { side: "AWAY", edge: edgeA, odds: oa }

    ].sort((a,b) => b.edge - a.edge);



    const best = edges[0];

    if (best.edge > 0) {

        txt.push("");

        txt.push(`Sisi dengan edge terbesar: ${best.side} (edge ${fmt(best.edge)}% pada odds ${best.odds.toFixed(2)})`);

    } else {

        txt.push("");

        txt.push("Tidak ada sisi dengan edge positif signifikan berdasarkan input saat ini.");

    }



    txt.push("");

    PSZ.log(txt.join("\n"));



    PSZ.state.market_edge = { edges, best };

    return PSZ.state.market_edge;

};



// Parlay AI Builder

PSZ.runParlayAI = function () {

    const comp  = PSZ.state.composite || PSZ.runCompositeModel();

    const conf  = PSZ.state.confidence || PSZ.runConfidenceIndex();

    const ou    = PSZ.state.ou_heat || PSZ.runOUHeat();

    const dxg   = PSZ.state.dxg || PSZ.dynamicXG();

    const teams = PSZ.getTeams();



    const txt = [];

    txt.push("=== PARLAY AI BUILDER ===");

    txt.push(`Match: ${teams.home} vs ${teams.away}`);

    txt.push(`C-Index: ${conf.cIndex ? conf.cIndex.toFixed(1) : "n/a"} (${conf.tag || "-"})`);

    txt.push("");



    const legs_safe = [];

    const legs_mid  = [];

    const legs_risky= [];



    const mainSide = (() => {

        if (comp.pHome >= comp.pDraw && comp.pHome >= comp.pAway) return "HOME";

        if (comp.pAway >= comp.pDraw && comp.pAway >= comp.pHome) return "AWAY";

        return "DRAW";

    })();



    if (mainSide === "HOME") {

        legs_safe.push("Double Chance 1X");

        legs_mid.push("HOME");

        legs_risky.push("HOME -1 Asian Handicap / HOME & Over 2.5");

    } else if (mainSide === "AWAY") {

        legs_safe.push("Double Chance X2");

        legs_mid.push("AWAY");

        legs_risky.push("AWAY -1 Asian Handicap / AWAY & Over 2.5");

    } else {

        legs_safe.push("Pendekatan hati-hati pada 1X2 (misalnya handicap kecil sisi yang lebih kuat).");

        legs_mid.push("Fulltime Draw jika odds mendukung.");

        legs_risky.push("Draw dengan kombinasi OU/BTTS sesuai pola xG.");

    }



    if (ou.tag === "HIGH OVER ZONE") {

        legs_safe.push("Over 1.5 Goals");

        legs_mid.push("Over 2.5 Goals");

        legs_risky.push("Over 3.5 Goals / BTTS & Over 2.5");

    } else if (ou.tag === "LOW / UNDER ZONE") {

        legs_safe.push("Under 3.5 Goals");

        legs_mid.push("Under 2.5 Goals");

        legs_risky.push("Under 1.5 Goals (stake kecil) / score rendah.");

    } else {

        legs_mid.push("BTTS YES jika odds wajar dan sejalan dengan xG.");

    }



    if (dxg.total_xg > 3.0) {

        legs_mid.push("BTTS YES");

    } else if (dxg.total_xg < 2.1) {

        legs_mid.push("BTTS NO");

    }



    txt.push("Leg SAFE:");

    legs_safe.forEach(l => txt.push("- " + l));



    txt.push("");

    txt.push("Leg MEDIUM:");

    legs_mid.forEach(l => txt.push("- " + l));



    txt.push("");

    txt.push("Leg RISKY:");

    legs_risky.forEach(l => txt.push("- " + l));



    txt.push("");

    txt.push("Gunakan kombinasi leg ini sesuai strategi dan odds nyata.");

    txt.push("");



    PSZ.log(txt.join("\n"));



    PSZ.state.parlay_ai = { legs_safe, legs_mid, legs_risky };

    return PSZ.state.parlay_ai;

};



// Team Identity

PSZ.runTeamIdentity = function () {

    const { pressH, pressA } = PSZ.getPressing();

    const errH  = PSZ.num("home_err");

    const errA  = PSZ.num("away_err");

    const stabH = PSZ.num("home_stab");

    const stabA = PSZ.num("away_stab");

    const momH  = PSZ.num("home_mom");

    const momA  = PSZ.num("away_mom");

    const teams = PSZ.getTeams();



    const profile = (press, err, stab, mom) => {

        const tags = [];



        if (press >= 8) tags.push("Pressing tinggi");

        else if (press >= 6) tags.push("Pressing aktif");

        else tags.push("Blok tengah / rendah");



        if (err >= 7) tags.push("Defence rawan kesalahan");

        else if (err <= 3) tags.push("Defence relatif solid");



        if (stab >= 7) tags.push("Stabil");

        else if (stab <= 3) tags.push("Fluktuatif");



        if (mom >= 7) tags.push("Momentum naik");

        else if (mom <= 3) tags.push("Momentum turun");



        return tags;

    };



    const homeTags = profile(pressH, errH, stabH, momH);

    const awayTags = profile(pressA, errA, stabA, momA);



    const txt = [];

    txt.push("=== TEAM IDENTITY ===");

    txt.push(`${teams.home}:`);

    homeTags.forEach(t => txt.push("- " + t));



    txt.push("");

    txt.push(`${teams.away}:`);

    awayTags.forEach(t => txt.push("- " + t));

    txt.push("");

PSZ.log(txt.join("\n"));



    PSZ.state.team_identity = { homeTags, awayTags };

    return PSZ.state.team_identity;

};



// ======================================================

// SUPREME ENGINE — META AI DECISION

// ======================================================

PSZ.runSupremeEngine = function () {

    const teams = PSZ.getTeams();



    const TCI        = PSZ.state.tci_profile || PSZ.autoTCI();

    const dxg        = PSZ.state.dxg         || PSZ.dynamicXG();

    const prime      = PSZ.state.prime       || PSZ.runPrime();

    const hybrid     = PSZ.state.hybrid      || PSZ.runHybrid();

    const infinity   = PSZ.state.infinity    || PSZ.runInfinity();

    const ou         = PSZ.state.ou_heat     || PSZ.runOUHeat();

    const scoregrid  = PSZ.state.scoregrid   || PSZ.runScoreGrid();

    const composite  = PSZ.state.composite   || PSZ.runCompositeModel();

    const confidence = PSZ.state.confidence  || PSZ.runConfidenceIndex();

    const identity   = PSZ.state.team_identity || PSZ.runTeamIdentity();



    const tempoG = TCI.tempo?.global ?? (

        ((TCI.tempoH || 5) + (TCI.tempoA || 5)) / 2

    );

    const chaosG = TCI.chaos?.global ?? (

        ((TCI.chaosH || 5) + (TCI.chaosA || 5)) / 2

    );

    const riskIndex = infinity.riskIndex ?? ((tempoG + chaosG) / 2);



    const pickSide = (pHome, pDraw, pAway) => {

        if (pHome >= pDraw && pHome >= pAway) return "HOME";

        if (pAway >= pDraw && pAway >= pHome) return "AWAY";

        return "DRAW";

    };



    const mainPrime = pickSide(prime.pHome, prime.pDraw, prime.pAway);

    const mainComp  = pickSide(composite.pHome, composite.pDraw, composite.pAway);



    let conflictTag = "MODEL CONSENSUS";

    if (mainPrime !== mainComp) {

        conflictTag = "MODEL CONFLICT";

    }



    const cIndex        = confidence.cIndex ?? 50;

    const predict       = confidence.predictability ?? 5;



    let   lockLevel     = "UNLOCKED";

    let   lockComment   = "Model dalam zona normal.";



    if (chaosG >= 8 || cIndex < 40 || predict < 4) {

        lockLevel   = "HARD LOCK";

        lockComment = "Risiko tinggi / confidence rendah. Hindari stake besar.";

    } else if (chaosG >= 6 || cIndex < 55) {

        lockLevel   = "SOFT LOCK";

        lockComment = "Ada sinyal volatilitas. Gunakan stake lebih kecil dari normal.";

    }



    let bestSide = mainComp;

    let bestMarket = "";

    if (bestSide === "HOME") {

        bestMarket = "HOME atau 1X (bergantung odds dan konteks).";

    } else if (bestSide === "AWAY") {

        bestMarket = "AWAY atau X2 (bergantung odds dan konteks).";

    } else {

        bestMarket = "DRAW / handicap kecil sesuai tim yang lebih diunggulkan model.";

    }



    let bestOU = "";

    if (ou.tag === "HIGH OVER ZONE") {

        bestOU = "Kecenderungan ke arah pasar over gol.";

    } else if (ou.tag === "LOW / UNDER ZONE") {

        bestOU = "Kecenderungan ke arah pasar under gol.";

    } else {

        bestOU = "Zona netral OU, perlu konfirmasi lewat odds dan info pertandingan.";

    }



    let flow = "";

    if (tempoG >= 8 && dxg.total_xg >= 3.0) {

        flow = "Tempo tinggi dan volume peluang besar, potensi permainan terbuka.";

    } else if (tempoG <= 4 && dxg.total_xg <= 2.2) {

        flow = "Tempo cenderung rendah, permainan lebih terkendali dan hati-hati.";

    } else {

        flow = "Tempo dan volume peluang berada di area menengah, sensitif terhadap momentum.";

    }



    const homeID = identity.homeTags ? identity.homeTags.join(", ") : "-";

    const awayID = identity.awayTags ? identity.awayTags.join(", ") : "-";



    const recoSafe   = [];

    const recoMain   = [];

    const recoRisky  = [];

    const recoAvoid  = [];



    if (cIndex >= 60 && chaosG <= 7) {

        if (bestSide === "HOME") recoSafe.push("1X (Home atau Draw)");

        else if (bestSide === "AWAY") recoSafe.push("X2 (Away atau Draw)");

        else recoSafe.push("Handicap +0.5 ke sisi yang lebih kuat di model.");

    } else {

        recoSafe.push("Fokus pada OU konservatif (misalnya Under 3.5 atau Over 1.5) sesuai pola xG dan heat.");

    }



    recoMain.push(bestMarket);

    recoMain.push(bestOU);



    if (ou.tag === "HIGH OVER ZONE" && dxg.total_xg >= 3.2) {

        recoRisky.push("Over garis tinggi atau kombinasi win & over, disesuaikan dengan odds.");

    } else if (ou.tag === "LOW / UNDER ZONE" && dxg.total_xg <= 2.0) {

        recoRisky.push("Under garis rendah atau scoreline sempit, dengan ukuran stake terkontrol.");

    } else {

        recoRisky.push("Kombinasi dari jalur utama dengan odds lebih besar, tetap memperhatikan karakter match.");

    }



    if (conflictTag !== "MODEL CONSENSUS") {

        recoAvoid.push("Menumpuk stake besar di 1X2 satu sisi saja.");

    }

    if (lockLevel === "HARD LOCK") {

        recoAvoid.push("All-in, akumulasi besar, dan eskalasi stake pada match dengan pola serupa.");

    }



    const txt = [];

    txt.push("===============================================");

    txt.push("=== SUPREME ENGINE — META AI DECISION MODE ===");

    txt.push("===============================================");

    txt.push(`Match              : ${teams.home} vs ${teams.away}`);

    txt.push(`Tempo / Chaos      : ${tempoG.toFixed(2)} / ${chaosG.toFixed(2)} | RiskIndex: ${riskIndex.toFixed(2)}`);

    txt.push(`Total Dynamic xG   : ${dxg.total_xg.toFixed(2)} | OU Heat: ${ou.tag}`);

    txt.push("");

    txt.push("MODEL SNAPSHOT:");

    txt.push(`- PRIME main side      : ${mainPrime}`);

    txt.push(`- COMPOSITE main side  : ${mainComp}`);

    txt.push(`- Confidence Index     : ${cIndex.toFixed(1)} / 100 (${confidence.tag || "-"})`);

    txt.push(`- Predictability       : ${predict.toFixed(2)} / 10`);

    txt.push(`- Model Conflict Status: ${conflictTag}`);

    txt.push("");

    txt.push("TEAM IDENTITY (ringkas):");

    txt.push(`- ${teams.home}: ${homeID}`);

    txt.push(`- ${teams.away}: ${awayID}`);

    txt.push("");

    txt.push("AI GAMEFLOW ESTIMATE:");

    txt.push(flow);

    txt.push("");

    txt.push("AILOCK (kontrol agresivitas):");

    txt.push(`- Status  : ${lockLevel}`);

    txt.push(`- Catatan : ${lockComment}`);

    txt.push("");

    txt.push("RECO ENGINE — kategori rekomendasi (berbasis input saat ini):");

    txt.push("SAFE / LOW RISK:");

    recoSafe.forEach(r => txt.push("• " + r));

    txt.push("");

    txt.push("MAIN / CORE IDEA:");

    recoMain.forEach(r => txt.push("• " + r));

    txt.push("");

    txt.push("RISKY / HIGH REWARD:");

    recoRisky.forEach(r => txt.push("• " + r));

    txt.push("");

    if (recoAvoid.length > 0) {

        txt.push("AVOID / HATI-HATI:");

        recoAvoid.forEach(r => txt.push("• " + r));

        txt.push("");

    }

    txt.push("Semua output ini murni hasil perhitungan model dari input yang diisi saat ini.");

    txt.push("Tetap gabungkan dengan informasi nyata (lineup, kondisi tim, jadwal) sebelum keputusan akhir.");

    txt.push("");



    PSZ.log(txt.join("\n"));

};



// ======================================================

// BIND TOMBOL + STARTUP

// ======================================================

PSZ.bindButtons = function () {

    const b = (id, fn) => {

        const el = PSZ.el(id);

        if (el) el.onclick = fn;

    };



    // Core

    b("btn_auto", () => {

        PSZ.log("Menjalankan AUTO CALC (TCI v9 + Dynamic xG)...");

        PSZ.autoTCI();

        PSZ.dynamicXG();

    });



    b("btn_analyze", () => {

        PSZ.log("Menjalankan PRIME ENGINE...");

        PSZ.runPrime();

    });



    b("btn_hybrid", () => {

        PSZ.log("Menjalankan HYBRID ENGINE...");

        PSZ.runHybrid();

    });



    b("btn_grand_unified", () => {

        PSZ.log("Menjalankan INFINITY ENGINE...");

        PSZ.runInfinity();

    });



    b("btn_dxg", () => {

        PSZ.log("Menjalankan Dynamic xG...");

        PSZ.dynamicXG();

    });



    b("btn_ou_heat", () => {

        PSZ.log("Menjalankan OU HEAT...");

        PSZ.runOUHeat();

    });



    b("btn_scoregrid", () => {

        PSZ.log("Menjalankan CORRECT SCORE GRID...");

        PSZ.runScoreGrid();

    });



    b("btn_brm", () => {

        PSZ.log("Menjalankan BRM...");

        PSZ.runBRM();

    });



    // God Mode

    b("btn_composite", () => {

        PSZ.log("Menjalankan COMPOSITE MODEL...");

        PSZ.runCompositeModel();

    });



    b("btn_confidence", () => {

        PSZ.log("Menjalankan CONFIDENCE INDEX...");

        PSZ.runConfidenceIndex();

    });



    b("btn_market_edge", () => {

        PSZ.log("Menjalankan MARKET EDGE ANALYZER...");

        PSZ.runMarketEdge();

    });



    b("btn_parlay_ai", () => {

        PSZ.log("Menjalankan PARLAY AI BUILDER...");

        PSZ.runParlayAI();

    });



    b("btn_team_id", () => {

        PSZ.log("Menjalankan TEAM IDENTITY...");

        PSZ.runTeamIdentity();

    });



    // Supreme

    b("btn_supreme", () => {

        PSZ.log("Menjalankan SUPREME ENGINE (Meta AI Decision)...");

        PSZ.runSupremeEngine();

    });

};



document.addEventListener("DOMContentLoaded", function () {

    PSZ.bindButtons();

    PSZ.log("SUPREME PARLAY ENGINE siap. Isi data aktual, lalu gunakan Auto Calc dan tombol lain sesuai kebutuhan.");

});
</script>
</div>
</body>
</html>

